<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>BioC++ - solving daily bioinformatic tasks with C++ efficiently</title>

        <link rel="stylesheet" href="reveal.js-3.9.2/css/reset.css">
        <link rel="stylesheet" href="reveal.js-3.9.2/css/reveal.css">
        <link rel="stylesheet" href="reveal.js-3.9.2/css/theme/white.css">

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="reveal.js-3.9.2/lib/css/zenburn.css">

<style>
.rrahn {
    background: url('img/rrahn.jpg') no-repeat left top;
    background-size: 2.5em 2.5em;
    height: 2.5em;
    padding-left: 3em;
}
.marehr {
    background: url('img/marehr.jpg') no-repeat left top;
    background-size: 2.5em 2.5em;
    height: 2.5em;
    padding-left: 3em;
}
.slide-background::before {
    content: "";
    opacity: 1;
    top: 0.3em;
    left: 0;
    height: 1.4em;
    width: 100%;
    position: absolute;
    z-index: -1;

    background-image: url(img/denbi.svg), url(img/elixir.svg), url(img/mpi.svg), url(img/fu.svg);
    background-repeat: no-repeat, no-repeat, no-repeat;
    background-position: 30% 0em, 10%, 60% 0em, 90% 0em;
    background-size: auto 100%, auto 100%, auto 100%, auto 100%;
}
.backgrounds .slide-background:not(:first-child)::after {
    content: "René Rahn, Marcel Ehrhardt";
    font-size: 0.75em;
    opacity: 1;
    bottom: 0.3em;
    left: 0.5em;
    height: 1.4em;
    width: 100%;
    position: absolute;
    z-index: -1;

    /* background-image: url(img/denbi.svg), url(img/mpi.svg), url(img/fu.svg);
    background-repeat: no-repeat, no-repeat, no-repeat;
    background-position: 10% 0em, 50% 0em, 90% 0em;
    background-size: auto 100%, auto 100%, auto 100%; */
}
.live-coding
{
    background: url(img/source_code.svg) no-repeat center;
    background-size: 8em;
    height: 6em;
}
.time-slot, .small
{
    font-size: 0.75em;
}
</style>

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js-3.9.2/css/print/pdf.css' : 'reveal.js-3.9.2/css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>
    </head>
    <body>
        <div class="reveal">
            <div class="slides">

<section>
<h1>BioC++</h1>
<h3>solving daily bioinformatic tasks<br>with C++ efficiently</h3>

<p class='rrahn' style='text-align: left'> René Rahn (Max Planck Institute for Molecular Genetics)</p>
<p class='marehr' style='text-align: left'> Marcel Ehrhardt (Free University Berlin)</p>
</section>

<section data-transition="none-out">
<h3>Schedule<small>*</small>:</h3>
<ul>
    <li class="fragment"><span class='time-slot'>09:00 - 09:30</span> Setup</li>
    <li class="fragment"><span class='time-slot'>09:30 - 10:00</span> Introduction Talk</li>
    <li class="fragment"><span class='time-slot'>10:00 - 10:30</span> FASTQ -> FASTA conversion <span class='small'>(sequence files)</span></li>
    <li class="fragment"><em class='time-slot'>10:30 - 10:45 Coffee-Break</em></li>
    <li class="fragment"><span class='time-slot'>10:45 - 11:45</span> Simple quality filter <span class='small'>(range / lambda / tuple)</span></li>
    <li class="fragment"><em class='time-slot'>11:45 - 14:30 "short break"</em></li>
    <li class="fragment"><span class='time-slot'>14:30 - 16:10</span> Extended quality filter <span class='small'>(view / concept)</span></li>
    <li class="fragment"><span class='time-slot'>16:10 - 16:30</span> Evaluation & Wrap-Up Talk</li>
</ul>
</section>

<section data-transition="none-in">
<h3>Schedule<small>*</small>:</h3>
<ul>
    <li class="fragment highlight-blue grow"><span class='time-slot'>09:00 - 09:30</span> Setup</li>
    <li><span class='time-slot'>09:30 - 10:00</span> Introduction Talk</li>
    <li><span class='time-slot'>10:00 - 10:30</span> FASTQ -> FASTA conversion <span class='small'>(sequence files)</span></li>
    <li><em class='time-slot'>10:30 - 10:45 Coffee-Break</em></li>
    <li><span class='time-slot'>10:45 - 11:45</span> Simple quality filter <span class='small'>(range / lambda / tuple)</span></li>
    <li><em class='time-slot'>11:45 - 14:30 "short break"</em></li>
    <li><span class='time-slot'>14:30 - 16:10</span> Extended quality filter <span class='small'>(view / concept)</span></li>
    <li><span class='time-slot'>16:10 - 16:30</span> Evaluation & Wrap-Up Talk</li>
</ul>
</section>

<section>
<h6>Setup (I):</h6>
<pre class="fragment">Debian / Ubuntu:<code class="plaintext hljs">sudo apt install g++ cmake git</code></pre>
<pre class="fragment">Mac (XCode and Brew installed): <code class="plaintext hljs">brew install gcc</code></pre>
<pre class="fragment">Windows: ... ( ͡° ͜ʖ ͡°)</pre>
<pre class="fragment">Online Editor (50h/month for free, github or gitlab account):
<code class="plaintext hljs" data-noescape><a href="https://gitpod.io/#https://github.com/rrahn/learning-resources">https://gitpod.io/#https://github.com/rrahn/learning-resources</a></code></pre>
<pre class="fragment"><a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a> image:
<code class="plaintext hljs" data-noescape>on USB flash drive</code>or<code class="plaintext hljs" data-noescape><a href="http://ftp.seqan.de/workshop/2020/biocpp-vm.vdi">http://ftp.seqan.de/workshop/2020/biocpp-vm.vdi</a></code></pre>
</section>

<section data-markdown>
<textarea data-template>
###### Setup (II):

Download course-material:
<!-- .element: class="fragment" -->

```
git clone https://github.com/rrahn/learning-resources

cd learning-resources

git submodule update --init --recursive
```
<!-- .element: class="fragment" -->

Configure makescript:
<!-- .element: class="fragment" -->

```
mkdir build && cd build
cmake ../src/biocpp
```
<!-- .element: class="fragment" -->

Build:
<!-- .element: class="fragment" -->

```
make -j 4
```
<!-- .element: class="fragment" -->
</textarea>
</section>

<section>
<h3>Schedule<small>*</small>:</h3>
<ul>
    <li><span class='time-slot'>09:00 - 09:30</span> Setup</li>
    <li class="fragment highlight-blue grow"><span class='time-slot'>09:30 - 10:00</span> Introduction Talk</li>
    <li><span class='time-slot'>10:00 - 10:30</span> FASTQ -> FASTA conversion <span class='small'>(sequence files)</span></li>
    <li><em class='time-slot'>10:30 - 10:45 Coffee-Break</em></li>
    <li><span class='time-slot'>10:45 - 11:45</span> Simple quality filter <span class='small'>(range / lambda / tuple)</span></li>
    <li><em class='time-slot'>11:45 - 14:30 "short break"</em></li>
    <li><span class='time-slot'>14:30 - 16:10</span> Extended quality filter <span class='small'>(view / concept)</span></li>
    <li><span class='time-slot'>16:10 - 16:30</span> Evaluation & Wrap-Up Talk</li>
</ul>
</section>

<section data-markdown>
<textarea data-template>
###### Introduction (I)

* <!-- .element: class="fragment" -->
  C++ einordnen R / Python / C++
* <!-- .element: class="fragment" -->
  community driven
* <!-- .element: class="fragment" -->
  ISO standard
* <!-- .element: class="fragment" -->
  everyone can propose changes
* <!-- .element: class="fragment" -->
  we have contributed as well
* <!-- .element: class="fragment" -->
  static type system
* <!-- .element: class="fragment" -->
  functional / procdural / oop (not done in the course)
* <!-- .element: class="fragment" -->
  imperative lanuage: for, if, sequential execution of steps
* <!-- .element: class="fragment" -->
  No garbage collection
* <!-- .element: class="fragment" -->
  generic programming (duck typing)
* <!-- .element: class="fragment" -->
  compilation
* <!-- .element: class="fragment" -->
  libraries
* <!-- .element: class="fragment" -->
  Not afraid of new (allocation)
</textarea>
</section>

<section data-markdown>
<textarea data-template>
### I come from C/Java/Python/C#...

How is C++ different?
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### C++ is ...

* <!-- .element: class="fragment" -->
  object-oriented (Java, Python, C#)
* <!-- .element: class="fragment" -->
  structured (Java, Python, C#, C)
* <!-- .element: class="fragment" -->
  imperative (Java, Python, C#, C)
* <!-- .element: class="fragment" -->
  procedural (Python, C)
* <!-- .element: class="fragment" -->
  functional (Python, C, C#)
* <!-- .element: class="fragment" -->
  generic (Java, Python, C#, C)
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Object-oriented

* <!-- .element: class="fragment" -->
  Models the world as objects
* <!-- .element: class="fragment" -->
  Objects provide interface
* <!-- .element: class="fragment" -->
  Objects can interact with each other
* <!-- .element: class="fragment" -->
  Design patterns "Gang of Four" to reduce complexity
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Structured & Imperative

* <!-- .element: class="fragment" -->
  Code executed in sequential order (assuming no concurrency)
* <!-- .element: class="fragment" -->
  Control flow through ...
  * <!-- .element: class="fragment" -->
    repetition: for, while, do-while, etc.
  * <!-- .element: class="fragment" -->
    branching: if, else
  * <!-- .element: class="fragment" -->
    multi-branching: switch, if else
* <!-- .element: class="fragment" -->
  Stateful algorithms
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Procedural & Functional

* <!-- .element: class="fragment" -->
  Breaking up monolithic code in functions
* <!-- .element: class="fragment" -->
  Opposed to object-oriented programming
* <!-- .element: class="fragment" -->
  Recursive
* <!-- .element: class="fragment" -->
  No shared state/immutable
* <!-- .element: class="fragment" -->
  Lambda-calculus
</textarea>
</section>

<section data-markdown>
<textarea data-template>
### Ok that's nice. But I learned that memory handling is difficult in C++.
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Is that so?

```cpp
#include <iostream>;
#include <vector>;

int main()
{
    std::vector char_vector{'H', 'e', 'l', 'l', 'o'};
    for (char c : char_vector)
        std::cout << c;

    std::cout << "\n";
    return 0;
}
```
<aside class='notes' data-markdown>
    Here 5 characters will be allocated and auto-magically will be deallocated.
    But where does it happen?
    We don't need to worry. The vector handles this for us.
</aside>
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Notes to Garbage Collection

* <!-- .element: class="fragment" -->
  C++ has no (language-builtin) garbage collection, but RAII
* <!-- .element: class="fragment" -->
  Java and C# support it. Allocate objects with `new`
* <!-- .element: class="fragment" -->
  Python uses reference counting but allows some sort of manual control
* <!-- .element: class="fragment" -->
  C, ... yeah well, that is another story

**Control over memory is a key for performance!**
<!-- .element: class="fragment" -->
</textarea>
</section>

<section data-markdown>
<textarea data-template>
### But there are so many cool libraries that I can use with the other programming languages?
<aside class='notes' data-markdown>

</aside>
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### C++ is a community driven language

* <!-- .element: class="fragment" -->
  C++ supports usage of third party libraries
* <!-- .element: class="fragment" -->
  Standard Template Library (STL) shipped with C++ compiler
* <!-- .element: class="fragment" -->
  Anyone can propose language or STL features
* <!-- .element: class="fragment" -->
  ISO committee manages standardization

<aside class='notes' data-markdown>
    If something is not supported there is likely to be a library that does it already.
    STL is rich on features.
    We actually have submitted two small papers, that were accepted for C++20.
    The language and the library will be standardized by an ISO committee.
</aside>
</textarea>
</section>

<section data-markdown>
<textarea data-template>
### Mhmm, I see your point. But especially Python makes it so easy to work with dynamic types.

<aside class='notes' data-markdown>
    Good point.
    What I will not do here is to start a fundamental discussion about what would be the better option.
    At the end this is mainly a subjective matter and each approach has its pros and cons.
    But for the sake of completion let us compare the differences.
</aside>
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Dynamic- vs static-typed languages

* <!-- .element: class="fragment" -->
  Dynamic-typed: The type is determined at run time by the interpreter.</li>
* <!-- .element: class="fragment" -->
  Static-typed: The type is determined at compile time by the compiler.</li>
* <!-- .element: class="fragment" -->
  C++ allows compile time type-deduction.</li>

<aside class='notes' data-markdown>
    Let me in the following show you on some very simple code example the evolution of C++ regarding type deduction.
</aside>
</textarea>
</section>

<section data-markdown data-transition="fade-out">
<textarea data-template>
```cpp
#include <iostream>
#include <vector>

int main()
{
    std::vector char_vector{'H', 'e', 'l', 'l', 'o'};
    for (char c : char_vector)
        std::cout << c;

    std::cout << "\n";
    return 0;
}
```

<aside class='notes' data-markdown>
    Remember our snippet from before. Here we created a vector of char and wanted to print the content.
    Now we want to extract the element-wise printing of the vector into a separate function.
</aside>
</textarea>
</section>

<section data-markdown data-transition="fade-in fade-out">
<textarea data-template>
```cpp
#include <iostream>
#include <vector>

void print(std::vector<char> const & obj)
{
    for (char c : obj)
        std::cout << c;

    std::cout << "\n";
}
```

<aside class='notes' data-markdown>
    This print function can now be used in the main and from other scopes to print a std::vector<char>.
    This is, however, cumbersome if we need to provide a print function for every type.
</aside>
</textarea>
</section>

<section data-markdown data-transition="fade-in fade-out">
<textarea data-template>
```cpp
#include <iostream>;

template <typename object_t>;
void print(object_t && obj) // object_t can be
{                           // std::vector<char>
    for (auto && c : obj)
        std::cout << c;

    std::cout << "\n";
}
```

<aside class='notes' data-markdown>
    Oh great! Now this code does work for any type.
    But, wait! What when we pass something that cannot be iterated?
</aside>
</textarea>
</section>

<section data-markdown data-transition="fade-in">
<textarea data-template>
```cpp
#include <iostream>;
#include <ranges>;

void print(std::ranges::input_range auto && obj)
{
    for (printable auto && c : obj)
        std::cout << c;

    std::cout << "\n";
}
```

<aside class='notes' data-markdown>
    Wow, so you don't need to know anything about your type.
    The only thing I need to ensure is that the obj is an input_range (What ever that means).
    And that the elements of this type can be printed.
    The rest is auto-magically done by the compiler.
    If the types do not match the constraints the compiler will inform me about the wrong types.
    Note, that this is valid C++-20 code.
</aside>
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### C++-Evolution

<img src="img/c++_standardisation.jpg" height="450">
<p class='small'>https://isocpp.org/std/status; accessed 23.02.2020</p>

<aside class='notes' data-markdown>
    In this course we will use modern C++ features available with C++20.
    We will incrementally build up a use case and learn the corresponding principles and how to use them
    to write efficient and expressive code.
</aside>
</textarea>
</section>

<section data-markdown>
<textarea data-template>
### Alright, alright, that looks cool and I am hooked to learn more!

But why should I care when I can do all this with Python/Java/C#?

<aside class='notes' data-markdown>
    Performance.
</aside>
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Performance

* <!-- .element: class="fragment" -->
  Data is growing and growing
* <!-- .element: class="fragment" -->
  The more information I have the more accurate could be my analysis
* <!-- .element: class="fragment" -->
  Shift from single-node to cluster based computation to hetereogeneous computing
* <!-- .element: class="fragment" -->
  TODO...

<aside class='notes' data-markdown>
    Performance.
</aside>
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### What will be covered in today's course

* <!-- .element: class="fragment" -->
  simple C++ command line application
* <!-- .element: class="fragment" -->
  Standard Template Library
* <!-- .element: class="fragment" -->
  SeqAn - an efficient and modern C++-library for sequence analysis
* <!-- .element: class="fragment" -->
  understanding and using `auto` in c++
* <!-- .element: class="fragment" -->
  understanding and using lambdas in C++
* <!-- .element: class="fragment" -->
  understanding and using ranges in C++
* <!-- .element: class="fragment" -->
  understanding and using concepts in C++

<aside class='notes' data-markdown>

</aside>
</textarea>
</section>

<section>
<h3>Schedule<small>*</small>:</h3>
<ul>
    <li><span class='time-slot'>09:00 - 09:30</span> Setup</li>
    <li><span class='time-slot'>09:30 - 10:00</span> Introduction Talk</li>
    <li class="fragment highlight-blue grow"><span class='time-slot'>10:00 - 10:30</span> FASTQ -> FASTA conversion <span class='small'>(sequence files)</span></li>
    <li><em class='time-slot'>10:30 - 10:45 Coffee-Break</em></li>
    <li><span class='time-slot'>10:45 - 11:45</span> Simple quality filter <span class='small'>(range / lambda / tuple)</span></li>
    <li><em class='time-slot'>11:45 - 14:30 "short break"</em></li>
    <li><span class='time-slot'>14:30 - 16:10</span> Extended quality filter <span class='small'>(view / concept)</span></li>
    <li><span class='time-slot'>16:10 - 16:30</span> Evaluation & Wrap-Up Talk</li>
</ul>
</section>

<section data-markdown>
<textarea data-template>
###### FASTQ -> FASTA conversion <span class='small'>(sequence files)</span> (I)

We write an application that will look like this:
<!-- .element: class="fragment" -->

```
$ ./fastq2fasta data/input.fq data/output.fa
```
<!-- .element: class="fragment" -->
</textarea>
</section>

<section data-markdown>
<script type="text/template">
###### FASTQ -> FASTA conversion <span class='small'>(sequence files)</span> (II)

How does a FASTQ and FASTA file look like?
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  FASTQ (`data/input.fq`):

  ```cpp
  @SEQ_ID
  GATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT
  +
  !''*((((***+))%%%++)(%%%%).1***-+*''))**55CCF>>>>>>CCCCCCC65
  ```
  <!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  FASTA (`data/output.fa`):

  ```cpp
  >SEQ_ID
  GATTTGGGGTTCAAAGCAGTATCGATCAAATAGTAAATCCATTTGTTCAACTCACAGTTT
  ```
  <!-- .element: class="fragment" -->
</script>
</section>

<section data-markdown>
<script type="text/template">
###### FASTQ -> FASTA conversion <span class='small'>(sequence files)</span> (III)</h6>

```
$ ./fastq2fasta data/input.fq data/output.fa
```
<!-- .element: class="fragment" -->

### How do we write this application?
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  Start with "hello world" programm. <!-- hello world -->
* <!-- .element: class="fragment" -->
  Read and use command-line arguments.
* <!-- .element: class="fragment" -->
  Use a library to read in a **fastq** file. <!-- fastq -> fasta -->
* <!-- .element: class="fragment" -->
  Use a library to write out a **fasta** file.
</script>
</section>

<section>
<p class=live-coding>Live Demo</p>

<aside class="notes" data-markdown>
    Start writing a simple program with hello world.
    Learning goals:
        * How to use Standard library functionality
        * What does #include mean
        * How to use standard library documentation: cppreference.com -> shared document.
        * Entry point of any program -> the main
        * String literal -> has to be the entry point of any program that captures command line arguments
        * Convert to C++.
        * Formatted files from SeqAn
        * Writing a file to the standard output.
</aside>
</section>

<section data-markdown>
<textarea data-template>
Have a look at the main:

```cpp
int main(int const argc, char const * argv[])
{ ... }
```

* <!-- .element: class="fragment" -->
  argc: The number of arguments passed to the program
* <!-- .element: class="fragment" -->
  argv: The arguments passed to the program as an array over c-style strings
* <!-- .element: class="fragment" -->
  program name is included and is accessed via argv[0]

<aside class="notes" data-markdown>
    argc >= 1
    |argv| = argc + 1
    argv[argc] == std::nullptr
    argv[0] -> program name or std::nullptr if not supported by environment

Task:
    The following program: ./foo var1 var2 var3
    What is the size of argc?
    a) 3
    b) 4
    c) 5
    d) 1
</aside>
</textarea>
</section>

<!-- In example of main reading command line arguments
    Use std::string_view to capture arguments.
    Rational:
        * Give them a name
        * Avoid working with pointer types (c-style string)
        * Avoid allocating memory
        * Avoid copying data -> non-owning semantics
-->

<section data-markdown>
<textarea data-template>
Open files from path.

```cpp
#include <seqan3/io/sequence_file/all.hpp>;

seqan3::sequence_file_input in{"path/to/my/file.fa"};
seqan3::sequence_file_input ingz{"path/to/my/file.fa.gz"};
```

* <!-- .element: class="fragment" -->
  automatic format detection
* <!-- .element: class="fragment" -->
  transparent decompression
* <!-- .element: class="fragment" -->
  secure parsing
</textarea>
</section>

<section data-markdown>
<textarea data-template>
Open files from stream.

```cpp
#include <seqan3/io/sequence_file/all.hpp>;

seqan3::sequence_file_output out{std::cout,
                                 seqan3::format_fasta{}};
```

* <!-- .element: class="fragment" -->
  format must be specified explicitly
</textarea>
</section>

<section>
<h3>Schedule<small>*</small>:</h3>
<ul>
    <li><span class='time-slot'>09:00 - 09:30</span> Setup</li>
    <li><span class='time-slot'>09:30 - 10:00</span> Introduction Talk</li>
    <li><span class='time-slot'>10:00 - 10:30</span> FASTQ -> FASTA conversion <span class='small'>(sequence files)</span></li>
    <li><em class='time-slot'>10:30 - 10:45 Coffee-Break</em></li>
    <li class="fragment highlight-blue grow"><span class='time-slot'>10:45 - 11:45</span> Simple quality filter <span class='small'>(range / lambda / tuple)</span></li>
    <li><em class='time-slot'>11:45 - 14:30 "short break"</em></li>
    <li><span class='time-slot'>14:30 - 16:10</span> Extended quality filter <span class='small'>(view / concept)</span></li>
    <li><span class='time-slot'>16:10 - 16:30</span> Evaluation & Wrap-Up Talk</li>
</ul>
</section>

<section data-markdown>
<textarea data-template>
###### Working with ranges

Extend the fastq2fasta program to only output reads with base qualities over a user given threshold.
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  Read user input interactively
* <!-- .element: class="fragment" -->
  Iterate over the fastq records
* <!-- .element: class="fragment" -->
  Write out fasta records with minimum quality criteria
</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Working with ranges

Learning objectives

<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  What is a range
* <!-- .element: class="fragment" -->
  How to generically access elements of a range
* <!-- .element: class="fragment" -->
  Use a range-based for-loop
* <!-- .element: class="fragment" -->
  Use a range-based algorithms
* <!-- .element: class="fragment" -->
  Using auto specifier to deduce type automatically
* <!-- .element: class="fragment" -->
  Work with tuples
* <!-- .element: class="fragment" -->
  Access fastq-file record-wise

</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Working with ranges

What is a range?

<img src="img/range.jpg">
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  range = pair of begin and end
* <!-- .element: class="fragment" -->
  end must be reachable from begin

</textarea>

<aside class="notes" data-markdown>
    To answer the question of what a range is, let's have a closer look at our std::string_view.
    At the beginning we said we will use a string view to handle the data stored in a c-string, with the benefit of no extra memory allocation.
    But what else does it give us? Looking at the documentation we can see that string view offers two member functions called .begin() and .end().
    In this case, begin() returns an iterator pointing to the first element of the string view and end returns us an iterator pointing to the past-the-end element.
    More generically, end returns an object that indicates the end of the range but is not itself part of the range.
    It immediately follows, that we cannot access an element that is pointed to by the end.

    In C++ iterators are used as a generic abstraction that allows us to write generic and efficient code.
    They hide the implementation of the data structure as well as the memory layout of the data and provide a unified access to the underlying elements. (Example?)
    All the STL algorithms are based on this paradigm as they operate on iterators and not on the specific range implementations.
    This brings many advantages, e.g. algorithms do not need to be implemented over and over again, reducing code complexity, improving maintainability and sustainability.
</aside>
</section>

<section data-markdown>
<textarea data-template>
###### Working with ranges

Ranges in the STL
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  std::string_view, std::string
* <!-- .element: class="fragment" -->
  std::vector, std::span
* <!-- .element: class="fragment" -->
  std::list, std::forward_list
* <!-- .element: class="fragment" -->
  std::map, std::set
* <!-- .element: class="fragment" -->
  std::unordered_map, std::unordered_set

</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Working with ranges

Element-wise access of range elements.
<!-- .element: class="fragment" -->

```cpp
#include <iostream>
#include <vector>

std::vector data{0, 1, 2, 3, 4, 5, 6};

for (auto && element : data)
    std::cout << element;
```
<!-- .element: class="fragment" -->

</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Working with ranges

What does `auto &&` do?
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  Automatic type-deduction
* <!-- .element: class="fragment" -->
  Automatic reference detection

</textarea>
</section>

<section>
<p class=live-coding>Live Demo</p>

<aside class="notes" data-markdown>
    Adapt the code from above and use range-based for loop to iterate over elements of the file.
    Use get<1> to display the id to the standard output.
</aside>
</section>

<section data-markdown>
<textarea data-template>
###### Working with tuples

SeqAn3 files are ranges over tuples
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  A tuple is a static collection of objects of different types
* <!-- .element: class="fragment" -->
  Access via special get interface
  * <!-- .element: class="fragment" -->
    via index:
    ```cpp
    std::get<1>(std::tuple{"first", 2})
    ```
  * <!-- .element: class="fragment" -->
    via type:
    ```cpp
    std::get<int>(std::tuple{"first", 2})
    ```

</textarea>
<aside class="notes" data-markdown>
    In SeqAn we offer additional access via enum. seqan3::field::id.
</aside>
</section>

<section>
<p class=live-coding>Live Demo</p>

<aside class="notes" data-markdown>
    Use field enum to print the id.
    Then access the quality.
    Write code that checks if there is any
</aside>
</section>

<section data-markdown>
<textarea data-template>
###### Lambda expressions

Consists of three main parts:
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  Capture block `[ ]`
* <!-- .element: class="fragment" -->
  Parameter block `( )`
* <!-- .element: class="fragment" -->
  Function body `{ }`

</textarea>
<aside class="notes" data-markdown>
    In SeqAn we offer additional access via enum. seqan3::field::id.
</aside>
</section>

<section>
<h3>Schedule<small>*</small>:</h3>
<ul>
    <li><span class='time-slot'>09:00 - 09:30</span> Setup</li>
    <li><span class='time-slot'>09:30 - 10:00</span> Introduction Talk</li>
    <li><span class='time-slot'>10:00 - 10:30</span> FASTQ -> FASTA conversion <span class='small'>(sequence files)</span></li>
    <li><em class='time-slot'>10:30 - 10:45 Coffee-Break</em></li>
    <li><span class='time-slot'>10:45 - 11:45</span> Simple quality filter <span class='small'>(range / lambda / tuple)</span></li>
    <li><em class='time-slot'>11:45 - 14:30 "short break"</em></li>
    <li class="fragment highlight-blue grow"><span class='time-slot'>14:30 - 16:10</span> Extended quality filter <span class='small'>(view / concept)</span></li>
    <li><span class='time-slot'>16:10 - 16:30</span> Evaluation & Wrap-Up Talk</li>
</ul>
</section>

<section data-markdown>
<textarea data-template>
###### Working with views

Extend the fastq2fasta program to only output reads with a minimum average base call quality.
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  TODO??
* <!-- .element: class="fragment" -->
  Iterate over the fastq records
* <!-- .element: class="fragment" -->
  Write out fasta records with minimum quality criteria

</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Working with views

Learning objectives
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  What is a view
* <!-- .element: class="fragment" -->
  How to chain ranges/views
* <!-- .element: class="fragment" -->
  Writing generic algorithms
* <!-- .element: class="fragment" -->
  Understanding and using concepts in generic code

</textarea>
</section>

<section data-markdown>
<textarea data-template>
###### Working with views

Extend the fastq2fasta program to handle paired-end reads.
<!-- .element: class="fragment" -->

* <!-- .element: class="fragment" -->
  Read user input interactively
* <!-- .element: class="fragment" -->
  Iterate over the fastq records
* <!-- .element: class="fragment" -->
  Write out fasta records with minimum quality criteria

</textarea>
</section>

<section>
<h3>Schedule<small>*</small>:</h3>
<ul>
    <li><span class='time-slot'>09:00 - 09:30</span> Setup</li>
    <li><span class='time-slot'>09:30 - 10:00</span> Introduction Talk</li>
    <li><span class='time-slot'>10:00 - 10:30</span> FASTQ -> FASTA conversion <span class='small'>(sequence files)</span></li>
    <li><em class='time-slot'>10:30 - 10:45 Coffee-Break</em></li>
    <li><span class='time-slot'>10:45 - 11:45</span> Simple quality filter <span class='small'>(range / lambda / tuple)</span></li>
    <li><em class='time-slot'>11:45 - 14:30 "short break"</em></li>
    <li><span class='time-slot'>14:30 - 16:10</span> Extended quality filter <span class='small'>(view / concept)</span></li>
    <li class="fragment highlight-blue grow"><span class='time-slot'>16:10 - 16:30</span> Evaluation & Wrap-Up Talk</li>
</ul>
</section>

<section data-markdown>
<script type="text/template">
###### Evaluation:

* <!-- .element: class="fragment" -->
  Please fill out the form and
* <!-- .element: class="fragment" -->
  rate what you liked and what you didn't.
* <!-- .element: class="fragment" -->
  you can also fill it out online
  https://de.surveymonkey.com/r/denbi-course?sc=cibi&id=000255
</script>
</section>

            </div>
        </div>

        <script src="reveal.js-3.9.2/js/reveal.js"></script>

        <script>
            // More info about config & dependencies:
            // - https://github.com/hakimel/reveal.js#configuration
            // - https://github.com/hakimel/reveal.js#dependencies
            Reveal.initialize({
                hash: true,
                dependencies: [
                    { src: 'reveal.js-3.9.2/plugin/markdown/marked.js' },
                    { src: 'reveal.js-3.9.2/plugin/markdown/markdown.js' },
                    // { src: 'reveal.js-3.9.2/plugin/highlight/highlight.js' },
                    { src: 'reveal.js-3.9.2/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'reveal.js-3.9.2/plugin/notes/notes.js', async: true }
                ]
            });
        </script>
    </body>
</html>
